<!DOCTYPE html>
<html>
    <head>
        <title>CJL - Projects</title>
        <link rel="stylesheet" href="projects.css">
    </head>

    <body>
        <nav class="navbar">
            <div class="navdiv">
                <div class="logo">
                    <img src="logo.jpg">
                    <a href="index.html">Connor J. Link</a>
                </div>
    
                <ul>
                    <li><a href="photography.html">Photography</a></li>
                    <li><a href="work.html">Experience</a></li>
                    <li><a href="projects.html">Projects</a></li>
                    <li><a href="contact.html">Contact</a></li>
                    <li><button class="theme-toggle" style="font-size: 20px; margin: 0; padding: 0; padding-left: 2px; padding-right: 2px;">â˜€</button></li>
                </ul>
            </div>
        </nav>
		
		<hr>

		<h1>My Projects</h1>
		
		<div class="projects">
			<h2>Titanium</h2>
		  <p>Curious about programming language design, I set out to build my own several years ago, with the end result being Titanium, my own custom compiled programming language built from scratch using the Flex/Bison toolchain and my own purpose-built code generator. Titanium exclusively targets CL8 assembly, my custom processor architecture's low-level code. While not feature rich, Titanium does offer a number of capabilities that developers have come to expect from modern languages, including function-scope local variables, pointer-based indirection, and descriptive compiler error messages. I am currently working on re-writing my existing implementation in pure C++&mdash;no lexer or parser generators in sight&mdash;the progress of which you can track in my growing YouTube time-lapse series <i>Coding a Programming Language</i>.</p>
			
		<hr>
			
		  <h2>CL8</h2>
			<p>A technology enthusiast at heart, I had always wondered how a raw stream of 1s and 0s got converted into tangible computation, much less how it could possibly represent a functional desktop operating system. Well, curiosity got the best of me nearing the end of 2022, and so I set forth on a multi-month-long exploration to learn just these things, a research exploration that culminated in the creation of my own custom processor architecture specfication: <i>CL8</i>. Despite lacking modern ease-of-use, security, and virtualization features, CL8 presents a unique take on classically-'60s 8-bit processor design. Featuring just four hardware registers, a mere few arithmetic instructions, and highly-limiting data-movement capabilities, CL8 forces its assembly developers to think like those of yesteryear&mdash;reaching an optimal solution notwithstanding platform constraints.</p>
			
			<p>I have created a variety of code repositories, with each encapsulating distinct functionality as part of the toolchain.</p>
			
			<p><b>Assembler: </b>With robust macro substitution and error handling capabilities, <a href="https://github.com/connorjlink/assembler/tree/main"><i>assembler</i></a> converts human-readable CL8 assembly language source code into raw CL8 machine code binaries</p>
			
			<p><b>Disassembler: </b>Driven by the need to debug pre-assembled and -compiled binaries, <a href="https://github.com/connorjlink/disassembler/tree/main"><i>disassembler</i></a> transforms raw CL8 machine code back into human-readable instruction listings</p>
			
			<p><b>Compiler: </b>Powered by GNU Flex and Bison, <a href="https://github.com/connorjlink/compiler/tree/main"><i>compiler</i></a> translates high-level Titanium source code into well-optimized low-level CL8 assembly source code</p>
			
			<p><b>Microcode: </b>Extensively utilizing the powerful C++ macro engine, <a href="https://github.com/connorjlink/microcode/tree/main"><i>microcode</i></a> contains source to serialize the CL8 micro-architecture control binary file</p>
			
			<p><b>Hardware: </b>An HDL-based implementation of the CL8 specification, <a href="https://github.com/connorjlink/hardware"><i>hardware</i></a> provides a robust description of and simulation basis for CL8 in Verilog</p>
			
			<p><b>Emulator: </b>A less-clunky solution than repetitive Verilog simulation, <a href="https://github.com/connorjlink/emulator/tree/main"><i>emulator</i> </a> provides a clean and user-friendly way to debug CL8 binaries from the command line</p>
			
			<hr>
			
			<h2>3-D Rendering</h2>
			<h3>Rasterization</h3>
			<p></p>
			
			<h3>Raytracing</h3>
			<p>Frustrated by the limitations of software-accelerated triangle rasterization rendering, I researched alternatives and wound up developing my own raytracing program. Despite starting out simple&mdash;capable only of rendering unlit spheres&mdash;I added more features to the software over time: a user-adjustable camera, sky lighting, reflections, path tracing, and global illumination to name a few.</p>
		</div>
		
        <hr>		

        <p class="copyright">&copy; 2023 Connor J. Link. All Rights Reserved.</p>
    </body>

    <script src="main.js"></script>
</html>