<!DOCTYPE html>
<html>
    <head>
        <Title>CJL - Home</Title>
        <link rel="stylesheet" href="projects.css">
    </head>

    <body>
        <nav class="navbar">
            <div class="navdiv">
                <div class="logo">
                    <img src="logo.jpg">
                    <a href="index.html">Connor J. Link</a>
                </div>
    
                <ul>
                    <li><a href="photography.html">Photography</a></li>
                    <li><a href="work.html">Work</a></li>
                    <li><a href="projects.html">Projects</a></li>
                    <li><a href="contact.html">Contact</a></li>
                </ul>
            </div>
        </nav>

		<h1>My Projects</h1>
		
		<div class="projects">
			<h2>Titanium</h2>
		  <p>Curious about programming language design, I set out to build my own several years ago, with the end result being Titanium, my own custom compiled programming lanugage built from scratch using the Flex/Bison toolchain and my own purpose-built code generator. Titanium exclusively targets CL8 assembly, my custom processor architecture's low-level code. While not feature rich, Titanium does offer a number of capabilities that developers have come to expect from modern languages, including function-scope local variables, pointer-based indirection, and descriptive compiler error messages. I am currently working on re-writing my existing implementation in pure C++&mdash;no lexer or parser generators in sight&mdash;the progress of which you can track in my growing YouTube timelapse series <i>Coding a Programming Language</i>.</p>
			
		  <h2>CL8</h2>
			<p>A technology enthusiast at heart, I had always wondered how a raw stream of 1s and 0s got converted into tangible computation, much less how it could possibly represent a functional desktop operating system. Well, curiosity got the best of me nearing the end of 2022, and so I set forth on a multi-month-long exploration to learn just these things, a research exploration that culminated in the creation of my own custom processor architecture specfication: <i>CL8</i>. Despite lacking modern ease-of-use, security, and virtualization features, CL8 presents a unique take on classically-'60s 8-bit processor design. Featuring just four hardware registers, a mere few arithmetic instructions, and highly-limiting data-movement capabilities, CL8 forces its assembly developers into think like those of yesteryear&mdash;reaching an optimal solution notwithstanding platform constraints.</p>
			
			<p>I have created a variety of code repositories, with each encapsulating distinct functionality as part of the toolchain.</p>
			
			<p><b>Assembler: </b>With robust macro substitution and error handling capabilities, <a href="https://github.com/connorjlink/assembler/tree/main"><i>assembler</i></a> converts human-readable CL8 assembly language source code into raw CL8 machine code binaries</p>
			
			<p><b>Disassembler: </b>Driven by the need to debug pre-assembled and -compiled binaries, <a href="https://github.com/connorjlink/disassembler/tree/main"><i>disassembler</i></a> transforms raw CL8 machine code back into human-readable instruction listings</p>
			
			<p><b>Compiler: </b>Powered by GNU Flex and Bison, <a href="https://github.com/connorjlink/compiler/tree/main"><i>compiler</i></a> translates high-level Titanium source code into well-optimized low-level CL8 assembly source code</p>
			
			<p><b>Microcode: </b>Extensively utilizing the powerful C++ macro engine, <a href="https://github.com/connorjlink/microcode/tree/main"><i>microcode</i></a> contains source to serialize the CL8 microarchitecture control binary file</p>
		</div>
		
        <hr>		

        <p class="copyright">&copy; 2023 Connor J. Link. All Rights Reserved.</p>
    </body>
</html>